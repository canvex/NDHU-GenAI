{% extends "layouts/base.html" %}

{% block title %} Forms General {% endblock %}

<!-- Element injected in the BODY element -->
{% block body_class %} sidebar-mini {% endblock body_class %}

<!-- Specific Page CSS goes HERE  -->
{% block stylesheets %}

<!-- Google Font: Source Sans Pro -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&display=fallback">
<!-- Font Awesome -->
<link rel="stylesheet" href="/static/assets/plugins/fontawesome-free/css/all.min.css">
<!-- Theme style -->
<link rel="stylesheet" href="/static/assets/css/adminlte.min.css">

{% endblock stylesheets %}

<style>
  /*å³éµé¸å–®*/
  #contextMenu {
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    padding: 5px;
    border-radius: 4px;
    font-size: 14px;
  }

  #contextMenu div {
    padding: 4px 10px;
    cursor: pointer;
  }

  #contextMenu div:hover {
    background: #f0f0f0;
  }
  #loading {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0,0,0,0.5);  /* é»‘è‰²åŠé€æ˜èƒŒæ™¯ */
  z-index: 9999;
}

#loading .spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

#loading span {
  color: white;
  font-size: 18px;
}



  
  body {
    display: flex;
  }

  .container {
    flex: 2;
    text-align: center;
  }

  .sidebar {
    width: 300px;
    padding: 10px;
    border-left: 1px solid #ccc;
  }

  canvas {
  border: 1px solid black;
  cursor: crosshair;
  width: 100%;           /* æ»¿ç‰ˆå®¹å™¨å¯¬ */
  max-width: 1000px;     /* å¯è‡ªèª¿æœ€å¤§å¯¬ */
  height: auto;
  display: block;
  margin: 0 auto;
}



  ul {
    list-style-type: none;
    padding: 0;
  }

  li {
    padding: 5px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
  }
</style>

{% block content %}

<div class="content-wrapper">
  <!-- Content Header (Page header) -->
  <section class="content-header">
    <div class="container-fluid">
      <div class="row mb-2">
        <div class="col-sm-6">
          {# <h1>Upload Form</h1>#}
        </div>
        <div class="col-sm-6">
          <ol class="breadcrumb float-sm-right">
            <li class="breadcrumb-item"><a href="#">Home</a></li>
            <li class="breadcrumb-item">Upload Form</li>
            <li class="breadcrumb-item active">select</li>
          </ol>
        </div>
      </div>
    </div><!-- /.container-fluid -->
  </section>

  <!-- Main content -->
  <section class="content">
    <div class="container-fluid">
      <!-- s<div class="row"> -->
      <!-- left column -->



      <form id="uploadForm" onsubmit="return false;" style="padding-left: 200px;padding-right:200px; text-align:center;">
        <div class="card-body">
        </div>
        <div class="form-group">
          <label for="fileInput">ä¸Šå‚³æª”æ¡ˆ</label>
          <div class="input-group">
            <div class="custom-file" style="padding-left: 100px;padding-right: 100px;">
              <input type="file" class="custom-file-input" id="fileInput" name="file">
              <label class="custom-file-label" for="fileInput" style="text-align: left;">è«‹é¸æ“‡æª”æ¡ˆ</label>
            </div>
            <div class="input-group-append">
              <button type="button" class="input-group-text" onclick="uploadImage()">Upload</button>
            </div>
          </div>



          <br /><br />
          <button onclick="exportData()" class="btn btn-secondary">åŒ¯å‡º JSON</button>
          <input type="file" id="importFile" accept="application/json" onchange="importData(event)" />


          <br /><br />
          <button onclick="downloadImage()" class="btn btn-info">ä¸‹è¼‰åœ–ç‰‡</button>
          <br /><br />
          <!-- æ¨¡å¼åˆ‡æ›é–‹é—œå€åŸŸ -->
          <!-- <div id="mode-switcher">
            <label for="mode-toggle">æ¨¡å¼åˆ‡æ›ï¼š</label>
            <input type="checkbox" id="mode-toggle" />
            <span id="mode-status">ç›®å‰æ˜¯å•é¡Œæ¨¡å¼</span>
          </div>


          <div class="form-group">
            <label class="switch">
              <input type="checkbox">
              <span class="slider round">ç›®å‰æ˜¯</span>
            </label>
          </div> -->


          <style>
            /* Toggle é–‹é—œæ¨£å¼ */
            .switch {
              position: relative;
              display: inline-block;
              width: 60px;
              height: 30px;
              margin-right: 10px;
            }
          
            .switch input {
              opacity: 0;
              width: 0;
              height: 0;
            }
          
            .slider {
              position: absolute;
              cursor: pointer;
              background-color: #ccc;
              border-radius: 34px;
              top: 0; left: 0;
              right: 0; bottom: 0;
              transition: 0.4s;
            }
          
            .slider:before {
              content: "";
              position: absolute;
              height: 22px;
              width: 22px;
              left: 4px;
              bottom: 4px;
              background-color: white;
              border-radius: 50%;
              transition: 0.4s;
            }
          
            input:checked + .slider {
              background-color: #4CAF50;
            }
          
            input:checked + .slider:before {
              transform: translateX(30px);
            }
          
            /* åœ“è§’é–‹é—œ */
            .slider.round {
              border-radius: 34px;
            }
          
            .slider.round:before {
              border-radius: 50%;
            }
          </style>
          
          <div id="mode-switcher">
            <label class="switch">
              <input type="checkbox" id="mode-toggle" onchange="toggleMode()">
              <span class="slider round"></span>
            </label>
            <span id="mode-status">ç›®å‰æ˜¯å•é¡Œæ¨¡å¼</span>
          </div>
          
         
          
          <!-- <canvas id="myCanvas" width="800" height="600"></canvas> -->

          <!-- å³éµé¸å–® -->
          <ul id="contextMenu" style="
          display: none;
          position: absolute;
          background: white;
          border: 1px solid gray;
          padding: 5px;"
          >
        
            <div id="editBtn">âœï¸ ç·¨è¼¯</div>
            <div id="deleteBtn">ğŸ—‘ï¸ åˆªé™¤</div>
            <li>è‡ªå‹•å¡«å…¥ç­”æ¡ˆï¼š</li>
            <ul id="answerOptions" style="padding-left: 15px"></ul>
          </ul>

          <div id="loading">
            <div class="spinner"></div>
            <span>è™•ç†ä¸­ï¼Œè«‹ç¨å€™...</span>
          </div>
          <pre id="output"></pre>
          <canvas id="canvas"></canvas>
          <br />
          <div class="sidebar" hidden>
            <h3>å•é¡Œ (Questions)</h3>
            <ul id="questionList"></ul>
            <h3>å›ç­” (Answers)</h3>
            <ul id="answerList"></ul>
          </div>






          <!-- /.card-body -->


          <!-- <a href="{{ url_for('home_blueprint.doc_fill') }}" class="btn btn-primary float-sm-right">
            ç¢ºèª
          </a> -->


      </form>



    </div>
    <!-- /.card -->

    <!-- Form Element sizes -->



    <!-- Input addon -->

    <!--/.col (right) -->
</div>
<!-- /.row -->
</div><!-- /.container-fluid -->
</section>
<!-- /.content -->
</div>



<!-- <script>
  
  function toggleMode() {
    const status = document.getElementById('mode-status');
    const toggle = document.getElementById('mode-toggle');
    status.textContent = toggle.checked ? 'ç›®å‰æ˜¯å›ç­”æ¨¡å¼' : 'ç›®å‰æ˜¯å•é¡Œæ¨¡å¼';
  }
</script> -->

<script>
  // let isAnswerMode = false; // åˆå§‹ç‚ºå•é¡Œæ¨¡å¼

  // // å–å¾—é–‹é—œèˆ‡ç‹€æ…‹é¡¯ç¤ºå€åŸŸ
  // const modeToggle = document.getElementById("mode-toggle");
  // const modeStatus = document.getElementById("mode-status");

  // // ç›£è½é–‹é—œæ”¹è®Šäº‹ä»¶
  // modeToggle.addEventListener("change", () => {
  //   isAnswerMode = modeToggle.checked; // ç•¶é–‹é—œé–‹å•Ÿæ™‚æ˜¯ç­”æ¡ˆæ¨¡å¼ï¼Œå¦å‰‡æ˜¯å•é¡Œæ¨¡å¼

  //   // æ›´æ–°é¡¯ç¤ºçš„æ¨¡å¼
  //   if (isAnswerMode) {
  //     modeStatus.textContent = "ç›®å‰æ˜¯ç­”æ¡ˆæ¨¡å¼";
  //   } else {
  //     modeStatus.textContent = "ç›®å‰æ˜¯å•é¡Œæ¨¡å¼";
  //   }
  // });


  let isAnswerMode = false; // åˆå§‹ç‚ºå•é¡Œæ¨¡å¼

  // ç­‰ DOM è¼‰å…¥å®Œæˆå¾ŒåŸ·è¡Œ
  window.addEventListener("DOMContentLoaded", () => {
    const modeToggle = document.getElementById("mode-toggle");
    const modeStatus = document.getElementById("mode-status");

    // ç›£è½åˆ‡æ›äº‹ä»¶
    modeToggle.addEventListener("change", () => {
      isAnswerMode = modeToggle.checked;

      modeStatus.textContent = isAnswerMode
        ? "ç›®å‰æ˜¯ç­”æ¡ˆæ¨¡å¼"
        : "ç›®å‰æ˜¯å•é¡Œæ¨¡å¼";
    });
  });



  const upload = document.getElementById("fileInput");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const questionList = document.getElementById("questionList");
  let img = new Image();
  let fields = [];
  let imgScale = 1;
  let selectedField = null;
  let isDragging = false;
  let isResizing = false;
  let dragOffsetX, dragOffsetY;
  let startX, startY;
  let resizeCorner = null; // æ–°å¢ä¸€å€‹è®Šæ•¸ä¾†å„²å­˜é¸æ“‡çš„ç¸®æ”¾è§’è½
  let isDrawing = false;
  let originalFileName = "result.png"; // é è¨­ä¸‹è¼‰åœ–ç‰‡åç¨±
  const answerCandidates = []; //å­˜æ”¾å€‹äººè³‡æ–™ï¼Œanswerå³éµå¯ä»¥å¡«å…¥
  // å–å¾—ä»Šå¤©æ—¥æœŸï¼ˆæ ¼å¼ï¼š2025/04/25ï¼‰
  const today = new Date();
  const formattedDate = `${today.getFullYear()}/${String(
    today.getMonth() + 1
  ).padStart(2, "0")}/${String(today.getDate()).padStart(2, "0")}`;

  // åŠ å…¥ä»Šå¤©æ—¥æœŸ
  answerCandidates.push(formattedDate);
  // ç™¼é€ GET è«‹æ±‚åˆ° Flask API æ‹¿å€‹äººè³‡æ–™
  fetch("/api/profile")
    .then((response) => response.json())
    .then((data) => {
      // ä½¿ç”¨ Object.values() æå–æ‰€æœ‰çš„å€¼ï¼Œä¸¦å°‡å…¶åŠ å…¥ answerCandidates é™£åˆ—
      answerCandidates.push(...Object.values(data));
      console.log(answerCandidates); // ç¢ºèªè³‡æ–™å·²ç¶“åŠ å…¥é™£åˆ—
    })
    .catch((error) => console.error("Error fetching data:", error));
  upload.addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (file) {
      originalFileName = file.name; // å„²å­˜åŸå§‹æª”å
      const reader = new FileReader();
      reader.onload = function (e) {
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
  });

  img.onload = function () {
    // è¨­å®š canvas å¯¦éš›å¤§å°ç‚ºåœ–ç‰‡åŸå§‹å¤§å°
   // å›ºå®š canvas å¯¦éš›è§£æåº¦ç‚º 1000xå°æ‡‰é«˜ï¼ˆä¾åœ–ç‰‡æ¯”ä¾‹ï¼‰
const fixedCanvasWidth = 1000;
const originalWidth = img.naturalWidth;
const originalHeight = img.naturalHeight;

// è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹ï¼Œä¾åœ–ç‰‡åŸå§‹æ¯”ä¾‹è¨ˆç®—å°æ‡‰é«˜
const scale = fixedCanvasWidth / originalWidth;
const scaledHeight = originalHeight * scale;

// è¨­å®š canvas å¯¦éš›è§£æåº¦ï¼ˆç•«è³ªï¼‰
canvas.width = fixedCanvasWidth;
canvas.height = scaledHeight;

// è®“ CSS æ”¯æ´ RWD
canvas.style.width = "100%";         // è®“ç•«å¸ƒåœ¨è¦–è¦ºä¸Šå¡«æ»¿å®¹å™¨
canvas.style.maxWidth = "1500px";    // é™åˆ¶æœ€å¤§å¯¬åº¦ç‚º 1000px
canvas.style.height = "auto";        // è‡ªå‹•ç¶­æŒæ¯”ä¾‹
canvas.style.display = "block";
canvas.style.margin = "0 auto";

// ä½¿ç”¨ç­‰æ¯”ä¾‹ç¸®æ”¾ç¹ªåœ–
ctx.setTransform(scale, 0, 0, scale, 0, 0);  // è®“æ‰€æœ‰ç¹ªè£½å‹•ä½œéƒ½è‡ªå‹•ç¸®æ”¾
ctx.clearRect(0, 0, originalWidth, originalHeight); // æ¸…ç©ºç•«å¸ƒ
ctx.drawImage(img, 0, 0); // ç”¨åŸå§‹å¤§å°ç¹ªåœ–ï¼Œå¯¦éš›è‡ªå‹•è¢« scale ç¸®æ”¾


    // åœ¨é€™è£¡ç¹ªè£½æ¡†ç·šæˆ–æ–‡å­—ç­‰å…¶ä»–åœ–å½¢
    redrawCanvas();
  };
let startDragX = 0;
let startDragY = 0;

  // ç•¶æŒ‰ä¸‹æ»‘é¼ æ™‚
  canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / canvas.width;
  const y = (e.clientY - rect.top) / canvas.height;

  selectedField = fields.find(
    (f) =>
      x >= f.x && x <= f.x + f.width &&
      y >= f.y && y <= f.y + f.height
  );

  if (selectedField) {
    resizeCorner = getResizeCorner(x, y, selectedField);
    if (resizeCorner) {
      isResizing = true;
    } else {
      // ğŸ‘‰ å»¶é²å•Ÿå‹•æ‹–æ›³ï¼Œå…ˆè¨˜éŒ„æ»‘é¼ èµ·é»
      startDragX = x;
      startDragY = y;
      dragOffsetX = x - selectedField.x;
      dragOffsetY = y - selectedField.y;
      isDragging = false; // é‚„æ²’å•Ÿå‹•æ‹–æ›³
    }
    canvas.addEventListener("mousemove", onMouseMove);
  } else {
    startX = x;
    startY = y;
    isDrawing = true;
  }
});


  // ç•¶æ»‘é¼ ç§»å‹•æ™‚
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / canvas.width;
    const y = (e.clientY - rect.top) / canvas.height;

    // æª¢æŸ¥æ˜¯å¦æ»‘é¼ æ‡¸åœåœ¨æ¡†é¸å€åŸŸä¸Š
    const hoveredField = fields.find(
      (f) =>
        x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height
    );

    if (hoveredField) {
      canvas.style.cursor = "pointer"; // ç•¶æ»‘é¼ æ‡¸åœåœ¨æ¡†é¸å€åŸŸä¸Šï¼Œé¡¯ç¤ºå¯æ‹–æ›³æ¸¸æ¨™
    } else {
      canvas.style.cursor = "crosshair"; // å¦å‰‡ï¼Œæ¢å¾©é è¨­æ¸¸æ¨™
    }

    if (isDrawing) {
      redrawCanvas();
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.strokeRect(
        startX * canvas.width,
        startY * canvas.height,
        (x - startX) * canvas.width,
        (y - startY) * canvas.height
      );
    } else if (isDragging && selectedField) {
      // æ‹–æ›³æ¡†é¸
      selectedField.x = x - dragOffsetX;
      selectedField.y = y - dragOffsetY;
      redrawCanvas();
    } else if (isResizing && selectedField && resizeCorner) {
      // æ ¹æ“šé¸æ“‡çš„è§’è½ä¾†èª¿æ•´å¤§å°
      switch (resizeCorner) {
        case "topLeft":
          // æ›´æ–°å·¦ä¸Šè§’å¤§å°ï¼Œä¸¦ç¢ºä¿å¯¬åº¦å’Œé«˜åº¦ç‚ºæ­£æ•¸
          selectedField.width += selectedField.x - x;
          selectedField.height += selectedField.y - y;
          selectedField.x = x;
          selectedField.y = y;
          // ç¢ºä¿å¯¬åº¦å’Œé«˜åº¦æ˜¯æ­£æ•¸
          if (selectedField.width < 0) {
            selectedField.x = x - selectedField.width;
            selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
        case "topRight":
          // æ›´æ–°å³ä¸Šè§’å¤§å°
          selectedField.width = x - selectedField.x;
          selectedField.height += selectedField.y - y;
          selectedField.y = y;
          // ç¢ºä¿å¯¬åº¦å’Œé«˜åº¦æ˜¯æ­£æ•¸
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }

          // åµæ¸¬æ˜¯å¦æœ‰åè½‰ï¼Œå¦‚æœæ˜¯ï¼Œå°±åˆ‡æ›ç‚ºå³ä¸‹è§’
          if (selectedField.height < 0) {
            resizeCorner = "bottomRight";
          }
          break;
        case "bottomLeft":
          // æ›´æ–°å·¦ä¸‹è§’å¤§å°
          selectedField.width += selectedField.x - x;
          selectedField.height = y - selectedField.y;
          selectedField.x = x;
          // ç¢ºä¿å¯¬åº¦å’Œé«˜åº¦æ˜¯æ­£æ•¸
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
        case "bottomRight":
          // æ›´æ–°å³ä¸‹è§’å¤§å°
          selectedField.width = x - selectedField.x;
          selectedField.height = y - selectedField.y;
          // ç¢ºä¿å¯¬åº¦å’Œé«˜åº¦æ˜¯æ­£æ•¸
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
      }

      // é‡æ–°ç¹ªè£½ç•«å¸ƒï¼Œæ›´æ–°æ¡†é¸å€åŸŸ
      redrawCanvas();
    }
    updateFieldList();
  });

  let questionIdCounter = 0;
  let answerIdCounter = 0;
  // ç•¶æ»‘é¼ æ”¾é–‹æ™‚
  canvas.addEventListener("mouseup", (e) => {
    if (isDrawing) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / canvas.width;
      const y = (e.clientY - rect.top) / canvas.height;

      let inputValue = "";

      // æ ¹æ“šæ¨¡å¼ä¾†æ±ºå®šé¡¯ç¤ºå•é¡Œæˆ–ç­”æ¡ˆ
      if (!isAnswerMode) {
        // å•é¡Œæ¨¡å¼ï¼Œè®“ç”¨æˆ¶è¼¸å…¥æ¬„ä½åç¨±
        inputValue = prompt("è«‹è¼¸å…¥å•é¡Œåç¨±ï¼š");
        mode = "question";
      } else {
        // ç­”æ¡ˆæ¨¡å¼ï¼Œè®“ç”¨æˆ¶è¼¸å…¥æ¬„ä½ç­”æ¡ˆ
        inputValue = prompt("è«‹è¼¸å…¥dataç­”æ¡ˆï¼š");
        mode = "answer";
      }

      // å¦‚æœæœ‰è¼¸å…¥ï¼Œå‰‡ä¿å­˜æ¡†é¸å€åŸŸä¸¦æ›´æ–°
      if (inputValue) {
        const fieldId =
          mode === "question"
            ? `q${questionIdCounter++}`
            : `a${answerIdCounter++}`;
        fields.push({
          id: fieldId,
          mode: mode,
          name: inputValue, // æ ¹æ“šæ¨¡å¼ï¼Œè¼¸å…¥çš„æ˜¯å•é¡Œæˆ–ç­”æ¡ˆ
          x: Math.min(startX, x),
          y: Math.min(startY, y),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY),
        });
        updateFieldList();
      }

      isDrawing = false;
    }

    // çµæŸæ‹–æ›³ã€èª¿æ•´å¤§å°çš„ç‹€æ…‹
    isDragging = false;
    isResizing = false;
    resizeCorner = null;
    selectedField = null;

    canvas.removeEventListener("mousemove", onMouseMove);
    redrawCanvas(); // é‡æ–°ç¹ªè£½ç•«å¸ƒï¼Œé¡¯ç¤ºæ›´æ–°å¾Œçš„æ¡†é¸å€åŸŸ
  });

  const contextMenu = document.getElementById("contextMenu");
  selectedField = null; // ç”¨ä¾†è¨˜éŒ„ç›®å‰é¸ä¸­çš„æ¡†æ¡†

  // å³éµé¸å–®é¡¯ç¤ºé‚è¼¯
  canvas.addEventListener("contextmenu", function (e) {
    e.preventDefault();

    const box = getBoxAtMousePosition(e); // ä½ ä¹‹å‰å¯«å¥½çš„åˆ¤æ–·æ¡†æ¡†çš„å‡½å¼
    if (box) {
      selectedField = box; // è¨­å®šé¸ä¸­çš„æ¡†æ¡†
      // é¡¯ç¤ºé¸å–®
      contextMenu.style.top = `${e.pageY}px`;
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.display = "block"; // ==== é€™æ®µæ˜¯é‡é»ï¼šå¦‚æœæ˜¯ answer é¡å‹ï¼Œé¡¯ç¤ºé¸é … ====
      const answerList = document.getElementById("answerOptions");
      answerList.innerHTML = "";

      if (box.mode === "answer") {
        answerCandidates.forEach((text) => {
          const li = document.createElement("li");
          li.textContent = text;
          li.style.cursor = "pointer";
          li.addEventListener("click", () => {
            box.name = text;
            updateFieldList();
            redrawCanvas();
            contextMenu.style.display = "none";
          });
          answerList.appendChild(li);
        });
      }
    } else {
      contextMenu.style.display = "none";
    }
  });

  // ç·¨è¼¯æŒ‰éˆ•äº‹ä»¶
  document.getElementById("editBtn").addEventListener("click", () => {
    if (selectedField) {
      const newName = prompt("è«‹è¼¸å…¥æ–°çš„æ¨™ç±¤æ–‡å­—", selectedField.name); // æç¤ºè¼¸å…¥æ–°çš„åç¨±
      if (newName !== null && newName.trim() !== "") {
        selectedField.name = newName.trim(); // æ›´æ–°åç¨±
        updateFieldList(); // æ›´æ–°å³å´åˆ—è¡¨
        redrawCanvas(); // é‡ç¹ªç•«å¸ƒ
      }
    }
    contextMenu.style.display = "none"; // éš±è—å³éµé¸å–®
  });

  // åˆªé™¤æŒ‰éˆ•äº‹ä»¶
  document.getElementById("deleteBtn").addEventListener("click", () => {
    if (selectedField) {
      const index = fields.indexOf(selectedField); // æ‰¾åˆ°è¢«é¸ä¸­çš„æ¡†æ¡†åœ¨ `fields` ä¸­çš„ç´¢å¼•
      if (index !== -1) {
        fields.splice(index, 1); // åˆªé™¤æ¡†æ¡†
        updateFieldList(); // æ›´æ–°å³å´åˆ—è¡¨
        redrawCanvas(); // é‡ç¹ªç•«å¸ƒ
      }
    }
    contextMenu.style.display = "none"; // éš±è—å³éµé¸å–®
  });

  // é»æ“Šå…¶ä»–åœ°æ–¹æ™‚éš±è—é¸å–®
  document.addEventListener("click", (e) => {
    if (!contextMenu.contains(e.target)) {
      contextMenu.style.display = "none";
    }
  });

  function getBoxAtMousePosition(e) {
    const rect = canvas.getBoundingClientRect();

    // canvas å¯¬é«˜ç¸®æ”¾å¾Œï¼Œè½‰æ›æˆ 0~1 å€é–“çš„æ¯”ä¾‹åº§æ¨™
    const x = (e.clientX - rect.left) / canvas.width;
    const y = (e.clientY - rect.top) / canvas.height;

    return fields.find(
      (f) =>
        x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height
    );
  }

  let selectedBoxId = null; // è¨˜éŒ„ç›®å‰è¢«é¸åˆ°çš„ box

  function showContextMenu(x, y, boxId) {
    selectedBoxId = boxId;
    const menu = document.getElementById("contextMenu");
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    menu.style.display = "block";
  }

  function hideContextMenu() {
    document.getElementById("contextMenu").style.display = "none";
  }

  // æ ¹æ“šé¼ æ¨™é»æ“Šçš„ä½ç½®åˆ¤æ–·æ˜¯å¦é»æ“Šåˆ°è§’è½
  function getResizeCorner(x, y, field) {
    const cornerThreshold = 10; // é‚Šç•Œè·é›¢è‡¨ç•Œå€¼
    const left = field.x * canvas.width;
    const top = field.y * canvas.height;
    const right = (field.x + field.width) * canvas.width;
    const bottom = (field.y + field.height) * canvas.height;

    if (
      Math.abs(x * canvas.width - left) < cornerThreshold &&
      Math.abs(y * canvas.height - top) < cornerThreshold
    ) {
      return "topLeft";
    } else if (
      Math.abs(x * canvas.width - right) < cornerThreshold &&
      Math.abs(y * canvas.height - top) < cornerThreshold
    ) {
      return "topRight";
    } else if (
      Math.abs(x * canvas.width - left) < cornerThreshold &&
      Math.abs(y * canvas.height - bottom) < cornerThreshold
    ) {
      return "bottomLeft";
    } else if (
      Math.abs(x * canvas.width - right) < cornerThreshold &&
      Math.abs(y * canvas.height - bottom) < cornerThreshold
    ) {
      return "bottomRight";
    }
    return null;
  }

  function redrawCanvas(showBox = true) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 2;

    fields.forEach((f) => {
      const x = f.x * canvas.width;
      const y = f.y * canvas.height;
      const w = f.width * canvas.width;
      const h = f.height * canvas.height;

      // æ ¹æ“š mode è¨­å®šä¸åŒé¡è‰²
      if (showBox) {
        ctx.strokeStyle = f.mode === "question" ? "red" : "green"; // question = ç´…è‰²æ¡†, answer = ç¶ è‰²æ¡†
        ctx.strokeRect(x, y, w, h);

        // é¡¯ç¤º questionï¼ˆåœ¨æ¡†æ¡†ä¸Šæ–¹ï¼‰
        if (f.mode === "question") {
          ctx.fillStyle = "red";
          ctx.font = "bold 14px Arial";
          ctx.fillText(
            f.name,
            x,
            Math.max(y - 5, 14) // é¿å…æ–‡å­—è¶…å‡ºç•«å¸ƒ
          );
        }

        // é¡¯ç¤º answerï¼ˆåœ¨æ¡†æ¡†å…§ï¼‰
        if (f.mode === "answer") {
          ctx.fillStyle = "green";
          ctx.font = "22px Arial";
          ctx.fillText(
            f.name,
            x + 5, // ç¨å¾®å¾€å³ä¸€é»
            y + 30 // ç¨å¾®å¾€ä¸‹ï¼Œé¿å…å¤ªé é‚Š
          );
        }

        // ç•«å‡ºå››å€‹è§’è½çš„åœ“é»ï¼ˆæ–¹ä¾¿æ‹–æ›³ï¼‰

        const cornerSize = 5;
        ctx.fillStyle = "blue";
        const corners = [
          [f.x, f.y], // å·¦ä¸Š
          [f.x + f.width, f.y], // å³ä¸Š
          [f.x, f.y + f.height], // å·¦ä¸‹
          [f.x + f.width, f.y + f.height], // å³ä¸‹
        ];
        corners.forEach(([cx, cy]) => {
          ctx.beginPath();
          ctx.arc(
            cx * canvas.width,
            cy * canvas.height,
            cornerSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        });
      } else {
        // åªç•« answer çš„æ–‡å­—ï¼Œä¸ç•«æ¡†ã€ä¸ç•« questionã€ä¸ç•«è§’é»
        if (f.mode === "answer") {
          ctx.fillStyle = "green";
          ctx.font = "22px Arial";
          ctx.fillText(
            f.name,
            f.x * canvas.width + 5,
            f.y * canvas.height + 30
          );
        }
      }
    });
  }

  // æ›´æ–°æ¬„ä½åˆ—è¡¨
  function updateFieldList() {
    const answerList = document.getElementById("answerList");
    questionList.innerHTML = "";
    answerList.innerHTML = "";
    fields.forEach((f, index) => {
      let li = document.createElement("li");
      li.textContent = `${f.name} (x: ${f.x.toFixed(2)}, y: ${f.y.toFixed(
        2
      )})`;
      // ç·¨è¼¯åç¨±æŒ‰éˆ•
      let editBtn = document.createElement("button");
      editBtn.textContent = "ç·¨è¼¯";
      editBtn.onclick = () => {
        let newName = prompt("è«‹è¼¸å…¥æ–°çš„åç¨±ï¼š", f.name);
        if (newName !== null && newName.trim() !== "") {
          fields[index].name = newName.trim();
          updateFieldList();
          redrawCanvas();
        }
      };

      // åˆªé™¤æŒ‰éˆ•
      let deleteBtn = document.createElement("button");
      deleteBtn.textContent = "åˆªé™¤";
      deleteBtn.onclick = () => {
        fields.splice(index, 1);
        updateFieldList();
        redrawCanvas();
      };
      li.appendChild(editBtn);
      li.appendChild(deleteBtn);
      // æ ¹æ“š mode é¡å‹ï¼ŒåŠ å…¥å°æ‡‰çš„æ¸…å–®
      if (f.mode === "question") {
        questionList.appendChild(li);
      } else if (f.mode === "answer") {
        answerList.appendChild(li);
      }
    });
  }
  // åŒ¯å‡ºæ¡†é¸è³‡æ–™
  function exportData() {
    const absoluteFields = fields.map((f) => ({
      mode: f.mode, // ä¿®æ­£é€™è£¡ï¼Œç¢ºä¿æ¯å€‹æ¡†éƒ½æœ‰è‡ªå·±çš„æ¨¡å¼
      name: f.name,
      x: Math.round(f.x * img.width),
      y: Math.round(f.y * img.height),
      width: Math.round(f.width * img.width),
      height: Math.round(f.height * img.height),
      id: f.id,
    }));

    const dataStr =
      "data:text/json;charset=utf-8," +
      encodeURIComponent(JSON.stringify(absoluteFields, null, 2));
    const downloadAnchor = document.createElement("a");
    downloadAnchor.setAttribute("href", dataStr);
    downloadAnchor.setAttribute("download", "bounding_boxes.json");
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    downloadAnchor.remove();
  }

  // åŒ¯å…¥æ¡†é¸è³‡æ–™
  function importData(event) {
    const file = event.target.files[0];

    // ç¢ºä¿å³ä½¿é¸æ“‡ç›¸åŒçš„æª”æ¡ˆä¹Ÿæœƒè§¸ç™¼ change äº‹ä»¶
    event.target.value = "";

    if (file) {
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const importedFields = JSON.parse(e.target.result);

          if (!img.complete) {
            img.onload = () =>
              updateFieldsWithRelativeCoordinates(importedFields);
          } else {
            updateFieldsWithRelativeCoordinates(importedFields);
          }

          // æ›´æ–°ç›®å‰çš„ ID ç·¨è™Ÿè¨ˆæ•¸å™¨
          questionIdCounter = 0;
          answerIdCounter = 0;
          updateIdCountersFromFields(importedFields);
        } catch (error) {
          alert("ç„¡æ³•è§£æ JSON æª”æ¡ˆ");
        }
      };
      reader.readAsText(file);
    }
  }

  function updateFieldsWithRelativeCoordinates(importedFields) {
    fields = importedFields.map((f) => ({
      ...f,
      x: f.x / img.width,
      y: f.y / img.height,
      width: f.width / img.width,
      height: f.height / img.height,
    }));
    updateFieldList();
    redrawCanvas();
  }

  document
    .getElementById("importBtn")
    .addEventListener("change", importData, false);
  document
    .getElementById("exportBtn")
    .addEventListener("click", exportData, false);

  function uploadImage() {
    let fileInput = document.getElementById("fileInput").files[0];
    if (!fileInput) {
      alert("è«‹é¸æ“‡åœ–ç‰‡");
      return;
    }

    let formData = new FormData();
    formData.append("file", fileInput);

    // é¡¯ç¤º loading å‹•ç•«
    document.getElementById("loading").style.display = "flex"; // é¡¯ç¤º loading å‹•ç•«
    document.getElementById("output").textContent = ""; // æ¸…ç©ºä¹‹å‰çš„çµæœ
   
    fetch("/doc_select", {
      method: "POST",
      body: formData,
    })
      .then((response) => {
        if (response.status === 403) {
          throw new Error("403"); // æ‰‹å‹•ä¸Ÿå‡ºéŒ¯èª¤ï¼Œè®“å®ƒé€² catch
        }
        return response.json(); // å…¶ä»–ç‹€æ³æ­£å¸¸è™•ç†
      })
      .then((data) => {
        // éš±è— loading å‹•ç•«
        document.getElementById("loading").style.display = "none";

        // æª¢æŸ¥æ˜¯å¦æœ‰éŒ¯èª¤è¨Šæ¯
        if (data.error) {
          alert("éŒ¯èª¤: " + data.error); // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        } else {
          try {
            console.log("èª¿ç”¨ handleApiResponse ä¹‹å‰çš„è³‡æ–™:", data);
            handleApiResponse(data); // ğŸ”¹ å‘¼å«è™•ç†å‡½å¼
            // document.getElementById("output").textContent = JSON.stringify(
            //   data,
            //   null,
            //   2
            // ); // é¡¯ç¤º JSON çµæœ
          } catch (error) {
            console.error("è™•ç† API å›æ‡‰æ™‚ç™¼ç”ŸéŒ¯èª¤:", error); // ğŸ”´ è¨˜éŒ„éŒ¯èª¤
            alert("è™•ç†å›æ‡‰æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æŸ¥çœ‹ Console è¨Šæ¯ï¼");
          }
        }
      })
      .catch((error) => {
        console.error("éŒ¯èª¤:", error);
        // éš±è— loading å‹•ç•«
        document.getElementById("loading").style.display = "none";
        if (error.message === "403") {
          alert("å¸³è™Ÿå·²ç™»å‡ºï¼Œè«‹é‡æ–°ç™»å…¥");
        } else {
          alert("ä¸Šå‚³å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦ï¼\néŒ¯èª¤è¨Šæ¯ï¼š" + error.message);
        }
      });
  }
  function handleApiResponse(data) {
    console.log("ğŸ”¹ API å›æ‡‰:", data);

    if (data.error) {
      alert("âŒ éŒ¯èª¤ï¼š" + data.error);
      return;
    }

    questionIdCounter = 0;
    answerIdCounter = 0;
    if (data.ocr_data && img.complete) {
      updateFieldsWithRelativeCoordinates(data.ocr_data);
      updateIdCountersFromFields(data.ocr_data); // âœ… åŠ é€™è¡Œ
    } else {
      img.onload = () => {
        updateFieldsWithRelativeCoordinates(data.ocr_data);
        updateIdCountersFromFields(data.ocr_data); // âœ… åŠ é€™è¡Œ
      };
    }
  }

  function downloadImage() {
    // å…ˆç”¨ä¸é¡¯ç¤ºæ¡†æ¡†çš„æ–¹å¼é‡ç•«ä¸€æ¬¡
    redrawCanvas(false);

    // çŸ­æš«å»¶é²ï¼Œç¢ºä¿ç•«é¢å·²é‡ç¹ªï¼ˆæœ‰æ™‚åœ–ç‰‡å¤§æˆ–ç€è¦½å™¨æ…¢ï¼‰
    setTimeout(() => {
      // å–å¾—åŸå§‹æª”æ¡ˆåç¨±ï¼Œä¸¦åœ¨å…¶å¾Œæ·»åŠ  "_filled"
      const fileNameWithoutExtension = originalFileName.replace(
        /\.[^/.]+$/,
        ""
      );
      const newFileName = `${fileNameWithoutExtension}_filled.png`;
      const link = document.createElement("a");
      link.download = newFileName;
      link.href = canvas.toDataURL("image/png");
      link.click();

      // å†æŠŠåŸæœ¬çš„ç•«é¢ç•«å›ä¾†ï¼ˆé¡¯ç¤ºæ¡†æ¡†ï¼‰
      redrawCanvas(true);
    }, 100); // 100ms å»¶é²é€šå¸¸å°±å¤ ç”¨äº†
  }

  //æ›´æ–°idç›®å‰åˆ°å¤šå°‘
  function updateIdCountersFromFields(fields) {
    fields.forEach((field) => {
      const id = field.id;
      if (id && id.startsWith("q")) {
        const num = parseInt(id.slice(1));
        if (!isNaN(num)) {
          questionIdCounter = Math.max(questionIdCounter, num + 1);
        }
      } else if (id && id.startsWith("a")) {
        const num = parseInt(id.slice(1));
        if (!isNaN(num)) {
          answerIdCounter = Math.max(answerIdCounter, num + 1);
        }
      }
    });
  }
</script>


{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block javascripts %}

<!-- jQuery -->
<script src="/static/assets/plugins/jquery/jquery.min.js"></script>
<!-- Bootstrap 4 -->
<script src="/static/assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- bs-custom-file-input -->
<script src="/static/assets/plugins/bs-custom-file-input/bs-custom-file-input.min.js"></script>
<!-- AdminLTE App -->
<script src="/static/assets/js/adminlte.min.js"></script>
<!-- AdminLTE for demo purposes -->
<script src="/static/assets/js/demo.js"></script>
<script>
  $(function () {
    bsCustomFileInput.init();
  });
</script>

{% endblock javascripts %}