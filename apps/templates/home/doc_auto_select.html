{% extends "layouts/base.html" %}

{% block title %} Forms General {% endblock %}

<!-- Element injected in the BODY element -->
{% block body_class %} sidebar-mini {% endblock body_class %}

<!-- Specific Page CSS goes HERE  -->
{% block stylesheets %}

<!-- Google Font: Source Sans Pro -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,400i,700&display=fallback">
<!-- Font Awesome -->
<link rel="stylesheet" href="/static/assets/plugins/fontawesome-free/css/all.min.css">
<!-- Theme style -->
<link rel="stylesheet" href="/static/assets/css/adminlte.min.css">

{% endblock stylesheets %}

<style>
  /*右鍵選單*/
  #contextMenu {
    background: white;
    border: 1px solid #ccc;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
    padding: 5px;
    border-radius: 4px;
    font-size: 14px;
  }

  #contextMenu div {
    padding: 4px 10px;
    cursor: pointer;
  }

  #contextMenu div:hover {
    background: #f0f0f0;
  }
  #loading {
  position: fixed;
  top: 0; left: 0;
  width: 100vw; height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0,0,0,0.5);  /* 黑色半透明背景 */
  z-index: 9999;
}

#loading .spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #3498db;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
  margin-right: 10px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

#loading span {
  color: white;
  font-size: 18px;
}



  
  body {
    display: flex;
  }

  .container {
    flex: 2;
    text-align: center;
  }

  .sidebar {
    width: 300px;
    padding: 10px;
    border-left: 1px solid #ccc;
  }

  canvas {
  border: 1px solid black;
  cursor: crosshair;
  width: 100%;           /* 滿版容器寬 */
  max-width: 1000px;     /* 可自調最大寬 */
  height: auto;
  display: block;
  margin: 0 auto;
}



  ul {
    list-style-type: none;
    padding: 0;
  }

  li {
    padding: 5px;
    border-bottom: 1px solid #ccc;
    display: flex;
    justify-content: space-between;
  }
</style>

{% block content %}

<div class="content-wrapper">
  <!-- Content Header (Page header) -->
  <section class="content-header">
    <div class="container-fluid">
      <div class="row mb-2">
        <div class="col-sm-6">
          {# <h1>Upload Form</h1>#}
        </div>
        <div class="col-sm-6">
          <ol class="breadcrumb float-sm-right">
            <li class="breadcrumb-item"><a href="#">Home</a></li>
            <li class="breadcrumb-item">Upload Form</li>
            <li class="breadcrumb-item active">select</li>
          </ol>
        </div>
      </div>
    </div><!-- /.container-fluid -->
  </section>

  <!-- Main content -->
  <section class="content">
    <div class="container-fluid">
      <!-- s<div class="row"> -->
      <!-- left column -->



      <form id="uploadForm" onsubmit="return false;" style="padding-left: 200px;padding-right:200px; text-align:center;">
        <div class="card-body">
        </div>
        <div class="form-group">
          <label for="fileInput">上傳檔案</label>
          <div class="input-group">
            <div class="custom-file" style="padding-left: 100px;padding-right: 100px;">
              <input type="file" class="custom-file-input" id="fileInput" name="file">
              <label class="custom-file-label" for="fileInput" style="text-align: left;">請選擇檔案</label>
            </div>
            <div class="input-group-append">
              <button type="button" class="input-group-text" onclick="uploadImage()">Upload</button>
            </div>
          </div>



          <br /><br />
          <button onclick="exportData()" class="btn btn-secondary">匯出 JSON</button>
          <input type="file" id="importFile" accept="application/json" onchange="importData(event)" />


          <br /><br />
          <button onclick="downloadImage()" class="btn btn-info">下載圖片</button>
          <br /><br />
          <!-- 模式切換開關區域 -->
          <!-- <div id="mode-switcher">
            <label for="mode-toggle">模式切換：</label>
            <input type="checkbox" id="mode-toggle" />
            <span id="mode-status">目前是問題模式</span>
          </div>


          <div class="form-group">
            <label class="switch">
              <input type="checkbox">
              <span class="slider round">目前是</span>
            </label>
          </div> -->


          <style>
            /* Toggle 開關樣式 */
            .switch {
              position: relative;
              display: inline-block;
              width: 60px;
              height: 30px;
              margin-right: 10px;
            }
          
            .switch input {
              opacity: 0;
              width: 0;
              height: 0;
            }
          
            .slider {
              position: absolute;
              cursor: pointer;
              background-color: #ccc;
              border-radius: 34px;
              top: 0; left: 0;
              right: 0; bottom: 0;
              transition: 0.4s;
            }
          
            .slider:before {
              content: "";
              position: absolute;
              height: 22px;
              width: 22px;
              left: 4px;
              bottom: 4px;
              background-color: white;
              border-radius: 50%;
              transition: 0.4s;
            }
          
            input:checked + .slider {
              background-color: #4CAF50;
            }
          
            input:checked + .slider:before {
              transform: translateX(30px);
            }
          
            /* 圓角開關 */
            .slider.round {
              border-radius: 34px;
            }
          
            .slider.round:before {
              border-radius: 50%;
            }
          </style>
          
          <div id="mode-switcher">
            <label class="switch">
              <input type="checkbox" id="mode-toggle" onchange="toggleMode()">
              <span class="slider round"></span>
            </label>
            <span id="mode-status">目前是問題模式</span>
          </div>
          
         
          
          <!-- <canvas id="myCanvas" width="800" height="600"></canvas> -->

          <!-- 右鍵選單 -->
          <ul id="contextMenu" style="
          display: none;
          position: absolute;
          background: white;
          border: 1px solid gray;
          padding: 5px;"
          >
        
            <div id="editBtn">✏️ 編輯</div>
            <div id="deleteBtn">🗑️ 刪除</div>
            <li>自動填入答案：</li>
            <ul id="answerOptions" style="padding-left: 15px"></ul>
          </ul>

          <div id="loading">
            <div class="spinner"></div>
            <span>處理中，請稍候...</span>
          </div>
          <pre id="output"></pre>
          <canvas id="canvas"></canvas>
          <br />
          <div class="sidebar" hidden>
            <h3>問題 (Questions)</h3>
            <ul id="questionList"></ul>
            <h3>回答 (Answers)</h3>
            <ul id="answerList"></ul>
          </div>






          <!-- /.card-body -->


          <!-- <a href="{{ url_for('home_blueprint.doc_fill') }}" class="btn btn-primary float-sm-right">
            確認
          </a> -->


      </form>



    </div>
    <!-- /.card -->

    <!-- Form Element sizes -->



    <!-- Input addon -->

    <!--/.col (right) -->
</div>
<!-- /.row -->
</div><!-- /.container-fluid -->
</section>
<!-- /.content -->
</div>



<!-- <script>
  
  function toggleMode() {
    const status = document.getElementById('mode-status');
    const toggle = document.getElementById('mode-toggle');
    status.textContent = toggle.checked ? '目前是回答模式' : '目前是問題模式';
  }
</script> -->

<script>
  // let isAnswerMode = false; // 初始為問題模式

  // // 取得開關與狀態顯示區域
  // const modeToggle = document.getElementById("mode-toggle");
  // const modeStatus = document.getElementById("mode-status");

  // // 監聽開關改變事件
  // modeToggle.addEventListener("change", () => {
  //   isAnswerMode = modeToggle.checked; // 當開關開啟時是答案模式，否則是問題模式

  //   // 更新顯示的模式
  //   if (isAnswerMode) {
  //     modeStatus.textContent = "目前是答案模式";
  //   } else {
  //     modeStatus.textContent = "目前是問題模式";
  //   }
  // });


  let isAnswerMode = false; // 初始為問題模式

  // 等 DOM 載入完成後執行
  window.addEventListener("DOMContentLoaded", () => {
    const modeToggle = document.getElementById("mode-toggle");
    const modeStatus = document.getElementById("mode-status");

    // 監聽切換事件
    modeToggle.addEventListener("change", () => {
      isAnswerMode = modeToggle.checked;

      modeStatus.textContent = isAnswerMode
        ? "目前是答案模式"
        : "目前是問題模式";
    });
  });



  const upload = document.getElementById("fileInput");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const questionList = document.getElementById("questionList");
  let img = new Image();
  let fields = [];
  let imgScale = 1;
  let selectedField = null;
  let isDragging = false;
  let isResizing = false;
  let dragOffsetX, dragOffsetY;
  let startX, startY;
  let resizeCorner = null; // 新增一個變數來儲存選擇的縮放角落
  let isDrawing = false;
  let originalFileName = "result.png"; // 預設下載圖片名稱
  const answerCandidates = []; //存放個人資料，answer右鍵可以填入
  // 取得今天日期（格式：2025/04/25）
  const today = new Date();
  const formattedDate = `${today.getFullYear()}/${String(
    today.getMonth() + 1
  ).padStart(2, "0")}/${String(today.getDate()).padStart(2, "0")}`;

  // 加入今天日期
  answerCandidates.push(formattedDate);
  // 發送 GET 請求到 Flask API 拿個人資料
  fetch("/api/profile")
    .then((response) => response.json())
    .then((data) => {
      // 使用 Object.values() 提取所有的值，並將其加入 answerCandidates 陣列
      answerCandidates.push(...Object.values(data));
      console.log(answerCandidates); // 確認資料已經加入陣列
    })
    .catch((error) => console.error("Error fetching data:", error));
  upload.addEventListener("change", (event) => {
    const file = event.target.files[0];
    if (file) {
      originalFileName = file.name; // 儲存原始檔名
      const reader = new FileReader();
      reader.onload = function (e) {
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }
  });

  img.onload = function () {
    // 設定 canvas 實際大小為圖片原始大小
   // 固定 canvas 實際解析度為 1000x對應高（依圖片比例）
const fixedCanvasWidth = 1000;
const originalWidth = img.naturalWidth;
const originalHeight = img.naturalHeight;

// 計算縮放比例，依圖片原始比例計算對應高
const scale = fixedCanvasWidth / originalWidth;
const scaledHeight = originalHeight * scale;

// 設定 canvas 實際解析度（畫質）
canvas.width = fixedCanvasWidth;
canvas.height = scaledHeight;

// 讓 CSS 支援 RWD
canvas.style.width = "100%";         // 讓畫布在視覺上填滿容器
canvas.style.maxWidth = "1500px";    // 限制最大寬度為 1000px
canvas.style.height = "auto";        // 自動維持比例
canvas.style.display = "block";
canvas.style.margin = "0 auto";

// 使用等比例縮放繪圖
ctx.setTransform(scale, 0, 0, scale, 0, 0);  // 讓所有繪製動作都自動縮放
ctx.clearRect(0, 0, originalWidth, originalHeight); // 清空畫布
ctx.drawImage(img, 0, 0); // 用原始大小繪圖，實際自動被 scale 縮放


    // 在這裡繪製框線或文字等其他圖形
    redrawCanvas();
  };
let startDragX = 0;
let startDragY = 0;

  // 當按下滑鼠時
  canvas.addEventListener("mousedown", (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / canvas.width;
  const y = (e.clientY - rect.top) / canvas.height;

  selectedField = fields.find(
    (f) =>
      x >= f.x && x <= f.x + f.width &&
      y >= f.y && y <= f.y + f.height
  );

  if (selectedField) {
    resizeCorner = getResizeCorner(x, y, selectedField);
    if (resizeCorner) {
      isResizing = true;
    } else {
      // 👉 延遲啟動拖曳，先記錄滑鼠起點
      startDragX = x;
      startDragY = y;
      dragOffsetX = x - selectedField.x;
      dragOffsetY = y - selectedField.y;
      isDragging = false; // 還沒啟動拖曳
    }
    canvas.addEventListener("mousemove", onMouseMove);
  } else {
    startX = x;
    startY = y;
    isDrawing = true;
  }
});


  // 當滑鼠移動時
  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / canvas.width;
    const y = (e.clientY - rect.top) / canvas.height;

    // 檢查是否滑鼠懸停在框選區域上
    const hoveredField = fields.find(
      (f) =>
        x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height
    );

    if (hoveredField) {
      canvas.style.cursor = "pointer"; // 當滑鼠懸停在框選區域上，顯示可拖曳游標
    } else {
      canvas.style.cursor = "crosshair"; // 否則，恢復預設游標
    }

    if (isDrawing) {
      redrawCanvas();
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 2;
      ctx.strokeRect(
        startX * canvas.width,
        startY * canvas.height,
        (x - startX) * canvas.width,
        (y - startY) * canvas.height
      );
    } else if (isDragging && selectedField) {
      // 拖曳框選
      selectedField.x = x - dragOffsetX;
      selectedField.y = y - dragOffsetY;
      redrawCanvas();
    } else if (isResizing && selectedField && resizeCorner) {
      // 根據選擇的角落來調整大小
      switch (resizeCorner) {
        case "topLeft":
          // 更新左上角大小，並確保寬度和高度為正數
          selectedField.width += selectedField.x - x;
          selectedField.height += selectedField.y - y;
          selectedField.x = x;
          selectedField.y = y;
          // 確保寬度和高度是正數
          if (selectedField.width < 0) {
            selectedField.x = x - selectedField.width;
            selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
        case "topRight":
          // 更新右上角大小
          selectedField.width = x - selectedField.x;
          selectedField.height += selectedField.y - y;
          selectedField.y = y;
          // 確保寬度和高度是正數
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }

          // 偵測是否有反轉，如果是，就切換為右下角
          if (selectedField.height < 0) {
            resizeCorner = "bottomRight";
          }
          break;
        case "bottomLeft":
          // 更新左下角大小
          selectedField.width += selectedField.x - x;
          selectedField.height = y - selectedField.y;
          selectedField.x = x;
          // 確保寬度和高度是正數
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
        case "bottomRight":
          // 更新右下角大小
          selectedField.width = x - selectedField.x;
          selectedField.height = y - selectedField.y;
          // 確保寬度和高度是正數
          if (selectedField.width < 0) {
            selectedField.x = x + selectedField.width;
            selectedField.width = -selectedField.width;
          }
          if (selectedField.height < 0) {
            selectedField.y = y + selectedField.height;
            selectedField.height = -selectedField.height;
          }
          break;
      }

      // 重新繪製畫布，更新框選區域
      redrawCanvas();
    }
    updateFieldList();
  });

  let questionIdCounter = 0;
  let answerIdCounter = 0;
  // 當滑鼠放開時
  canvas.addEventListener("mouseup", (e) => {
    if (isDrawing) {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / canvas.width;
      const y = (e.clientY - rect.top) / canvas.height;

      let inputValue = "";

      // 根據模式來決定顯示問題或答案
      if (!isAnswerMode) {
        // 問題模式，讓用戶輸入欄位名稱
        inputValue = prompt("請輸入問題名稱：");
        mode = "question";
      } else {
        // 答案模式，讓用戶輸入欄位答案
        inputValue = prompt("請輸入data答案：");
        mode = "answer";
      }

      // 如果有輸入，則保存框選區域並更新
      if (inputValue) {
        const fieldId =
          mode === "question"
            ? `q${questionIdCounter++}`
            : `a${answerIdCounter++}`;
        fields.push({
          id: fieldId,
          mode: mode,
          name: inputValue, // 根據模式，輸入的是問題或答案
          x: Math.min(startX, x),
          y: Math.min(startY, y),
          width: Math.abs(x - startX),
          height: Math.abs(y - startY),
        });
        updateFieldList();
      }

      isDrawing = false;
    }

    // 結束拖曳、調整大小的狀態
    isDragging = false;
    isResizing = false;
    resizeCorner = null;
    selectedField = null;

    canvas.removeEventListener("mousemove", onMouseMove);
    redrawCanvas(); // 重新繪製畫布，顯示更新後的框選區域
  });

  const contextMenu = document.getElementById("contextMenu");
  selectedField = null; // 用來記錄目前選中的框框

  // 右鍵選單顯示邏輯
  canvas.addEventListener("contextmenu", function (e) {
    e.preventDefault();

    const box = getBoxAtMousePosition(e); // 你之前寫好的判斷框框的函式
    if (box) {
      selectedField = box; // 設定選中的框框
      // 顯示選單
      contextMenu.style.top = `${e.pageY}px`;
      contextMenu.style.left = `${e.pageX}px`;
      contextMenu.style.display = "block"; // ==== 這段是重點：如果是 answer 類型，顯示選項 ====
      const answerList = document.getElementById("answerOptions");
      answerList.innerHTML = "";

      if (box.mode === "answer") {
        answerCandidates.forEach((text) => {
          const li = document.createElement("li");
          li.textContent = text;
          li.style.cursor = "pointer";
          li.addEventListener("click", () => {
            box.name = text;
            updateFieldList();
            redrawCanvas();
            contextMenu.style.display = "none";
          });
          answerList.appendChild(li);
        });
      }
    } else {
      contextMenu.style.display = "none";
    }
  });

  // 編輯按鈕事件
  document.getElementById("editBtn").addEventListener("click", () => {
    if (selectedField) {
      const newName = prompt("請輸入新的標籤文字", selectedField.name); // 提示輸入新的名稱
      if (newName !== null && newName.trim() !== "") {
        selectedField.name = newName.trim(); // 更新名稱
        updateFieldList(); // 更新右側列表
        redrawCanvas(); // 重繪畫布
      }
    }
    contextMenu.style.display = "none"; // 隱藏右鍵選單
  });

  // 刪除按鈕事件
  document.getElementById("deleteBtn").addEventListener("click", () => {
    if (selectedField) {
      const index = fields.indexOf(selectedField); // 找到被選中的框框在 `fields` 中的索引
      if (index !== -1) {
        fields.splice(index, 1); // 刪除框框
        updateFieldList(); // 更新右側列表
        redrawCanvas(); // 重繪畫布
      }
    }
    contextMenu.style.display = "none"; // 隱藏右鍵選單
  });

  // 點擊其他地方時隱藏選單
  document.addEventListener("click", (e) => {
    if (!contextMenu.contains(e.target)) {
      contextMenu.style.display = "none";
    }
  });

  function getBoxAtMousePosition(e) {
    const rect = canvas.getBoundingClientRect();

    // canvas 寬高縮放後，轉換成 0~1 區間的比例座標
    const x = (e.clientX - rect.left) / canvas.width;
    const y = (e.clientY - rect.top) / canvas.height;

    return fields.find(
      (f) =>
        x >= f.x && x <= f.x + f.width && y >= f.y && y <= f.y + f.height
    );
  }

  let selectedBoxId = null; // 記錄目前被選到的 box

  function showContextMenu(x, y, boxId) {
    selectedBoxId = boxId;
    const menu = document.getElementById("contextMenu");
    menu.style.left = `${x}px`;
    menu.style.top = `${y}px`;
    menu.style.display = "block";
  }

  function hideContextMenu() {
    document.getElementById("contextMenu").style.display = "none";
  }

  // 根據鼠標點擊的位置判斷是否點擊到角落
  function getResizeCorner(x, y, field) {
    const cornerThreshold = 10; // 邊界距離臨界值
    const left = field.x * canvas.width;
    const top = field.y * canvas.height;
    const right = (field.x + field.width) * canvas.width;
    const bottom = (field.y + field.height) * canvas.height;

    if (
      Math.abs(x * canvas.width - left) < cornerThreshold &&
      Math.abs(y * canvas.height - top) < cornerThreshold
    ) {
      return "topLeft";
    } else if (
      Math.abs(x * canvas.width - right) < cornerThreshold &&
      Math.abs(y * canvas.height - top) < cornerThreshold
    ) {
      return "topRight";
    } else if (
      Math.abs(x * canvas.width - left) < cornerThreshold &&
      Math.abs(y * canvas.height - bottom) < cornerThreshold
    ) {
      return "bottomLeft";
    } else if (
      Math.abs(x * canvas.width - right) < cornerThreshold &&
      Math.abs(y * canvas.height - bottom) < cornerThreshold
    ) {
      return "bottomRight";
    }
    return null;
  }

  function redrawCanvas(showBox = true) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    ctx.lineWidth = 2;

    fields.forEach((f) => {
      const x = f.x * canvas.width;
      const y = f.y * canvas.height;
      const w = f.width * canvas.width;
      const h = f.height * canvas.height;

      // 根據 mode 設定不同顏色
      if (showBox) {
        ctx.strokeStyle = f.mode === "question" ? "red" : "green"; // question = 紅色框, answer = 綠色框
        ctx.strokeRect(x, y, w, h);

        // 顯示 question（在框框上方）
        if (f.mode === "question") {
          ctx.fillStyle = "red";
          ctx.font = "bold 14px Arial";
          ctx.fillText(
            f.name,
            x,
            Math.max(y - 5, 14) // 避免文字超出畫布
          );
        }

        // 顯示 answer（在框框內）
        if (f.mode === "answer") {
          ctx.fillStyle = "green";
          ctx.font = "22px Arial";
          ctx.fillText(
            f.name,
            x + 5, // 稍微往右一點
            y + 30 // 稍微往下，避免太靠邊
          );
        }

        // 畫出四個角落的圓點（方便拖曳）

        const cornerSize = 5;
        ctx.fillStyle = "blue";
        const corners = [
          [f.x, f.y], // 左上
          [f.x + f.width, f.y], // 右上
          [f.x, f.y + f.height], // 左下
          [f.x + f.width, f.y + f.height], // 右下
        ];
        corners.forEach(([cx, cy]) => {
          ctx.beginPath();
          ctx.arc(
            cx * canvas.width,
            cy * canvas.height,
            cornerSize,
            0,
            Math.PI * 2
          );
          ctx.fill();
        });
      } else {
        // 只畫 answer 的文字，不畫框、不畫 question、不畫角點
        if (f.mode === "answer") {
          ctx.fillStyle = "green";
          ctx.font = "22px Arial";
          ctx.fillText(
            f.name,
            f.x * canvas.width + 5,
            f.y * canvas.height + 30
          );
        }
      }
    });
  }

  // 更新欄位列表
  function updateFieldList() {
    const answerList = document.getElementById("answerList");
    questionList.innerHTML = "";
    answerList.innerHTML = "";
    fields.forEach((f, index) => {
      let li = document.createElement("li");
      li.textContent = `${f.name} (x: ${f.x.toFixed(2)}, y: ${f.y.toFixed(
        2
      )})`;
      // 編輯名稱按鈕
      let editBtn = document.createElement("button");
      editBtn.textContent = "編輯";
      editBtn.onclick = () => {
        let newName = prompt("請輸入新的名稱：", f.name);
        if (newName !== null && newName.trim() !== "") {
          fields[index].name = newName.trim();
          updateFieldList();
          redrawCanvas();
        }
      };

      // 刪除按鈕
      let deleteBtn = document.createElement("button");
      deleteBtn.textContent = "刪除";
      deleteBtn.onclick = () => {
        fields.splice(index, 1);
        updateFieldList();
        redrawCanvas();
      };
      li.appendChild(editBtn);
      li.appendChild(deleteBtn);
      // 根據 mode 類型，加入對應的清單
      if (f.mode === "question") {
        questionList.appendChild(li);
      } else if (f.mode === "answer") {
        answerList.appendChild(li);
      }
    });
  }
  // 匯出框選資料
  function exportData() {
    const absoluteFields = fields.map((f) => ({
      mode: f.mode, // 修正這裡，確保每個框都有自己的模式
      name: f.name,
      x: Math.round(f.x * img.width),
      y: Math.round(f.y * img.height),
      width: Math.round(f.width * img.width),
      height: Math.round(f.height * img.height),
      id: f.id,
    }));

    const dataStr =
      "data:text/json;charset=utf-8," +
      encodeURIComponent(JSON.stringify(absoluteFields, null, 2));
    const downloadAnchor = document.createElement("a");
    downloadAnchor.setAttribute("href", dataStr);
    downloadAnchor.setAttribute("download", "bounding_boxes.json");
    document.body.appendChild(downloadAnchor);
    downloadAnchor.click();
    downloadAnchor.remove();
  }

  // 匯入框選資料
  function importData(event) {
    const file = event.target.files[0];

    // 確保即使選擇相同的檔案也會觸發 change 事件
    event.target.value = "";

    if (file) {
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const importedFields = JSON.parse(e.target.result);

          if (!img.complete) {
            img.onload = () =>
              updateFieldsWithRelativeCoordinates(importedFields);
          } else {
            updateFieldsWithRelativeCoordinates(importedFields);
          }

          // 更新目前的 ID 編號計數器
          questionIdCounter = 0;
          answerIdCounter = 0;
          updateIdCountersFromFields(importedFields);
        } catch (error) {
          alert("無法解析 JSON 檔案");
        }
      };
      reader.readAsText(file);
    }
  }

  function updateFieldsWithRelativeCoordinates(importedFields) {
    fields = importedFields.map((f) => ({
      ...f,
      x: f.x / img.width,
      y: f.y / img.height,
      width: f.width / img.width,
      height: f.height / img.height,
    }));
    updateFieldList();
    redrawCanvas();
  }

  document
    .getElementById("importBtn")
    .addEventListener("change", importData, false);
  document
    .getElementById("exportBtn")
    .addEventListener("click", exportData, false);

  function uploadImage() {
    let fileInput = document.getElementById("fileInput").files[0];
    if (!fileInput) {
      alert("請選擇圖片");
      return;
    }

    let formData = new FormData();
    formData.append("file", fileInput);

    // 顯示 loading 動畫
    document.getElementById("loading").style.display = "flex"; // 顯示 loading 動畫
    document.getElementById("output").textContent = ""; // 清空之前的結果
   
    fetch("/doc_select", {
      method: "POST",
      body: formData,
    })
      .then((response) => {
        if (response.status === 403) {
          throw new Error("403"); // 手動丟出錯誤，讓它進 catch
        }
        return response.json(); // 其他狀況正常處理
      })
      .then((data) => {
        // 隱藏 loading 動畫
        document.getElementById("loading").style.display = "none";

        // 檢查是否有錯誤訊息
        if (data.error) {
          alert("錯誤: " + data.error); // 顯示錯誤訊息
        } else {
          try {
            console.log("調用 handleApiResponse 之前的資料:", data);
            handleApiResponse(data); // 🔹 呼叫處理函式
            // document.getElementById("output").textContent = JSON.stringify(
            //   data,
            //   null,
            //   2
            // ); // 顯示 JSON 結果
          } catch (error) {
            console.error("處理 API 回應時發生錯誤:", error); // 🔴 記錄錯誤
            alert("處理回應時發生錯誤，請查看 Console 訊息！");
          }
        }
      })
      .catch((error) => {
        console.error("錯誤:", error);
        // 隱藏 loading 動畫
        document.getElementById("loading").style.display = "none";
        if (error.message === "403") {
          alert("帳號已登出，請重新登入");
        } else {
          alert("上傳失敗，請稍後再試！\n錯誤訊息：" + error.message);
        }
      });
  }
  function handleApiResponse(data) {
    console.log("🔹 API 回應:", data);

    if (data.error) {
      alert("❌ 錯誤：" + data.error);
      return;
    }

    questionIdCounter = 0;
    answerIdCounter = 0;
    if (data.ocr_data && img.complete) {
      updateFieldsWithRelativeCoordinates(data.ocr_data);
      updateIdCountersFromFields(data.ocr_data); // ✅ 加這行
    } else {
      img.onload = () => {
        updateFieldsWithRelativeCoordinates(data.ocr_data);
        updateIdCountersFromFields(data.ocr_data); // ✅ 加這行
      };
    }
  }

  function downloadImage() {
    // 先用不顯示框框的方式重畫一次
    redrawCanvas(false);

    // 短暫延遲，確保畫面已重繪（有時圖片大或瀏覽器慢）
    setTimeout(() => {
      // 取得原始檔案名稱，並在其後添加 "_filled"
      const fileNameWithoutExtension = originalFileName.replace(
        /\.[^/.]+$/,
        ""
      );
      const newFileName = `${fileNameWithoutExtension}_filled.png`;
      const link = document.createElement("a");
      link.download = newFileName;
      link.href = canvas.toDataURL("image/png");
      link.click();

      // 再把原本的畫面畫回來（顯示框框）
      redrawCanvas(true);
    }, 100); // 100ms 延遲通常就夠用了
  }

  //更新id目前到多少
  function updateIdCountersFromFields(fields) {
    fields.forEach((field) => {
      const id = field.id;
      if (id && id.startsWith("q")) {
        const num = parseInt(id.slice(1));
        if (!isNaN(num)) {
          questionIdCounter = Math.max(questionIdCounter, num + 1);
        }
      } else if (id && id.startsWith("a")) {
        const num = parseInt(id.slice(1));
        if (!isNaN(num)) {
          answerIdCounter = Math.max(answerIdCounter, num + 1);
        }
      }
    });
  }
</script>


{% endblock content %}

<!-- Specific Page JS goes HERE  -->
{% block javascripts %}

<!-- jQuery -->
<script src="/static/assets/plugins/jquery/jquery.min.js"></script>
<!-- Bootstrap 4 -->
<script src="/static/assets/plugins/bootstrap/js/bootstrap.bundle.min.js"></script>
<!-- bs-custom-file-input -->
<script src="/static/assets/plugins/bs-custom-file-input/bs-custom-file-input.min.js"></script>
<!-- AdminLTE App -->
<script src="/static/assets/js/adminlte.min.js"></script>
<!-- AdminLTE for demo purposes -->
<script src="/static/assets/js/demo.js"></script>
<script>
  $(function () {
    bsCustomFileInput.init();
  });
</script>

{% endblock javascripts %}